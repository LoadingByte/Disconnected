/*
 * This file is part of Disconnected.
 * Copyright (c) 2013 QuarterCode <http://www.quartercode.com/>
 *
 * Disconnected is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Disconnected is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Disconnected. If not, see <http://www.gnu.org/licenses/>.
 */

package com.quartercode.disconnected.server.registry;

import java.util.Collections;
import java.util.List;
import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import com.quartercode.disconnected.shared.util.registry.extra.NamedValue;

/**
 * A vulnerability source that is used to define the boundaries for generated vulnerabilities.
 * One source should address one kind of "generic" vulnerability.
 * A generator can then use the source to generate concrete vulnerabilities.<br>
 * <br>
 * The source defines the possible vulnerability {@link Action}s (which internally store probabilities for their occurrence).
 * Such actions describe what an attacked computer part (e.g. a program) should do.
 * 
 * @see Action
 * @see VulnerabilitySourceRegistry
 */
public class VulnerabilitySource implements NamedValue {

    private final String       name;
    private final String       usage;
    private final int          weight;
    private final List<Action> actions;

    /**
     * Creates a new vulnerability source data object.
     * 
     * @param name The name of the new source.
     * @param usage The usage string that defines which computer part (e.g. a program) should receive vulnerabilities generated by the new source.
     *        For example, if the source is used by the program {@code "webServer"}, its usage identifier would be {@code "worldProgram.webServer"}.
     * @param weight The weight of the new source relative to other sources.
     *        It is used to select a source when multiple sources are available for one computer part.
     * @param actions The {@link Action}s each generated vulnerability might have.
     *        Such actions describe what an attacked computer part (e.g. a program) should do.
     */
    public VulnerabilitySource(String name, String usage, int weight, List<Action> actions) {

        Validate.notNull(name, "Vulnerability source name cannot be null");
        Validate.isTrue(weight >= 0, "Vulnerability source weight must be >= 0: %d", weight);
        Validate.notNull(actions, "Vulnerability source action list cannot be null");

        this.name = name;
        this.usage = usage;
        this.weight = weight;
        this.actions = Collections.unmodifiableList(actions);
    }

    /**
     * Returns the name of the vulnerability source.
     * It might also be used to generate the name of a newly generated vulnerability.<br>
     * <br>
     * Note that the name is also used to identify the source.
     * Therefore, it should also contain the usage identifier ({@link #getUsage()}) as a namespace prefix.
     * For example, the vulnerability {@code "httpRequestBufferOverflow"} which is used for the program {@code "webServer"} should
     * have the name <code>"<i>worldProgram.webServer</i>.httpRequestBufferOverflow"</code>.
     * The <i>italic</i> part is the usage identifier.
     * 
     * @return The vulnerability source name.
     */
    @Override
    public String getName() {

        return name;
    }

    /**
     * Returns a usage string that defines which computer part (e.g. a program) should receive vulnerabilities generated by this source.
     * For example, if a source is used by the program {@code "webServer"}, its usage identifier would be {@code "worldProgram.webServer"}.<br>
     * <br>
     * The usage string is used by the {@link VulnerabilitySourceRegistry#getValuesByUsage(String...)} method to retrieve vulnerability sources
     * based on the beginning of the string.
     * For example, a program uses the usage string of sources to select which sources should be used for generating new vulnerabilities for it.
     * Therefore, the program does not need to store a list of vulnerability sources by itself because they are resolved dynamically.<br>
     * Note that the usage string should also be used as a namespace prefix for the name attribute ({@link #getName()}).
     * 
     * @return A string that describes the user of the vulnerability source.
     */
    public String getUsage() {

        return usage;
    }

    /**
     * Returns the weight of the vulnerability source relative to other sources.
     * It is used to select a source when multiple sources are available.
     * Sources with higher weights are selected more frequently than sources with lower weights.
     * For example, when a new vulnerability for a program is generated, the weights of the sources for that program are used to determine
     * which source is used.
     * 
     * @return The vulnerability source weight.
     */
    public int getWeight() {

        return weight;
    }

    /**
     * Returns the possible vulnerability {@link Action}s (which internally store probabilities for their occurrence).
     * Such actions describe what an attacked computer part (e.g. a program) should do.
     * When a new vulnerability is generated, a subset of these actions is selected based on their {@code vulnerabilityProbability} values.<br>
     * <br>
     * For example, a buffer overflow vulnerability could provide actions to crash a program or to execute a payload (e.g. for opening a remote session).
     * On the other hand, an SQL injection vulnerability could be used to access a database.<br>
     * <br>
     * Note that the {@code attackWeight}s are used to select which action is actually used for an attack later on.
     * 
     * @return The possible actions for generated vulnerabilities.
     */
    public List<Action> getActions() {

        return actions;
    }

    @Override
    public int hashCode() {

        return HashCodeBuilder.reflectionHashCode(this);
    }

    @Override
    public boolean equals(Object obj) {

        return EqualsBuilder.reflectionEquals(this, obj);
    }

    @Override
    public String toString() {

        return ToStringBuilder.reflectionToString(this);
    }

    /**
     * Vulnerability actions describe what an attacked computer part (e.g. a program) should do.
     * For example, a buffer overflow vulnerability could provide actions to crash a program or to execute a payload (e.g. for opening a remote session).
     * On the other hand, an SQL injection vulnerability could be used to access a database.<br>
     * <br>
     * When a new vulnerability is generated, a subset of all defined actions is selected based on their {@code vulnerabilityProbability} values
     * ({@link #getVulnerabilityProbability()}).
     * The algorithm iterates over all actions and randomly selects ones based on their probability (which must be &gt;= 0 and &lt;= 1).
     * As a result, all actions with the probability {@code 1} are always selected.
     * The resulting actions are put into the new vulnerability.<br>
     * <br>
     * When a new attack (it might also be an exploit) is "generated" from a vulnerability, the {@code attackWeight}s ({@link #getAttackWeight()}) are used
     * to determine which available action is used for the attack.
     * Actions with higher attack weights are more likely to be chosen than actions with lower attack weights.
     * For example, a {@code "crash"} action would usually have a higher attack weight than an {@code "executePayload"} action because it is easier to
     * write an exploit that crashes a program than to write an exploit that executes a binary payload.
     * 
     * @see VulnerabilitySource
     */
    public static class Action implements NamedValue {

        private final String name;
        private final float  vulnerabilityProbability;
        private final int    attackWeight;

        /**
         * Creates a new vulnerability action data object (should only be used inside a {@link VulnerabilitySource} object.
         * 
         * @param name The name of the new action.
         * @param vulnerabilityProbability The vulnerability probability (must be &gt;= 0 and &lt;= 1).
         *        See {@link #getVulnerabilityProbability()} for more details.
         * @param attackWeight The attack weight of the new action.
         *        See {@link #getAttackWeight()} for more details.
         */
        public Action(String name, float vulnerabilityProbability, int attackWeight) {

            Validate.notNull(name, "Vulnerability source action cannot be null");
            Validate.inclusiveBetween(0F, 1F, vulnerabilityProbability, "Vulnerability probability (chance) must be >= 0 and <= 1: %d", vulnerabilityProbability);
            Validate.isTrue(attackWeight >= 0, "Vulnerability source action attack weight must be >= 0: %d", attackWeight);

            this.name = name;
            this.vulnerabilityProbability = vulnerabilityProbability;
            this.attackWeight = attackWeight;
        }

        /**
         * Returns the name of the action.
         * For example, this might return {@code "crash"} or {@code "executePayload"}.
         * 
         * @return The action name.
         */
        @Override
        public String getName() {

            return name;
        }

        /**
         * Returns the probability of the action to be used for a newly generated vulnerability.
         * When a such a new vulnerability is generated, a subset of all defined actions is selected based on this value.
         * The algorithm iterates over all actions and randomly selects ones based on their probability (which must be &gt;= 0 and &lt;= 1).
         * As a result, all actions with the probability {@code 1} are always selected.
         * The resulting actions are put into the new vulnerability.
         * 
         * @return The vulnerability probability of the action (must be &gt;= 0 and &lt;= 1).
         */
        public float getVulnerabilityProbability() {

            return vulnerabilityProbability;
        }

        /**
         * Returns a weight that is used to determine which available action is used for an actual attack (e.g. an exploit) when it is "generated" from a vulnerability.
         * Actions with higher attack weights are more likely to be chosen than actions with lower attack weights.
         * For example, a {@code "crash"} action would usually have a higher attack weight than an {@code "executePayload"} action because it is easier to
         * write an exploit that crashes a program than to write an exploit that executes a binary payload.
         * 
         * @return The attack weight of the action.
         */
        public int getAttackWeight() {

            return attackWeight;
        }

        @Override
        public int hashCode() {

            return HashCodeBuilder.reflectionHashCode(this);
        }

        @Override
        public boolean equals(Object obj) {

            return EqualsBuilder.reflectionEquals(this, obj);
        }

        @Override
        public String toString() {

            return ToStringBuilder.reflectionToString(this);
        }

    }

}
