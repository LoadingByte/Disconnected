/*
 * This file is part of Disconnected.
 * Copyright (c) 2013 QuarterCode <http://quartercode.com/>
 *
 * Disconnected is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Disconnected is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Disconnected. If not, see <http://www.gnu.org/licenses/>.
 */

package com.quartercode.disconnected.server.world.comp.vuln;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import javax.xml.bind.annotation.XmlElement;
import org.apache.commons.lang3.Validate;
import com.quartercode.disconnected.server.registry.VulnSource;
import com.quartercode.disconnected.server.registry.VulnSource.Action;
import com.quartercode.disconnected.server.util.ProbabilityUtils;
import com.quartercode.disconnected.server.world.util.WorldNode;
import com.quartercode.jtimber.api.node.Node;
import com.quartercode.jtimber.api.node.wrapper.SubstituteWithWrapper;
import com.quartercode.jtimber.api.node.wrapper.collection.ListWrapper;

/**
 * A vulnerability container stores {@link Vulnerability vulnerabilities}, provides some access methods and allows to generate new vulnerabilities from {@link VulnSource vulnerability sources}.
 * It should be used for storing vulnerabilities instead of a plain list.
 *
 * @see Vulnerability
 * @see VulnSource
 */
public class VulnerabilityContainer extends WorldNode<Node<?>> {

    @XmlElement (name = "vulnerability")
    @SubstituteWithWrapper (ListWrapper.class)
    private final List<Vulnerability> vulnerabilities = new ArrayList<>();

    /**
     * Returns the {@link Vulnerability vulnerabilities} that are stored inside the container.
     * New vulnerabilities can be generated with {@link #generateVulnerability(VulnSource)} and {@link #generateVulnerabilities(Collection, int)}.
     *
     * @return The vulnerabilities stored by the container.
     */
    public List<Vulnerability> getVulnerabilities() {

        return Collections.unmodifiableList(vulnerabilities);
    }

    /**
     * Manually stores the given {@link Vulnerability} inside the container.
     * Note that you should try to generated new vulnerabilities instead of adding them manually.
     *
     * @param vulnerability The vulnerability to store in the container.
     */
    public void addVulnerability(Vulnerability vulnerability) {

        Validate.notNull(vulnerability, "Cannot add null vulnerability to vulnerability container");
        vulnerabilities.add(vulnerability);
    }

    /**
     * Manually removes the given {@link Vulnerability} from the container.
     * Note that you should try to avoid this method; it should only be used if your requirements need it.
     *
     * @param vulnerability The vulnerability to remove from the container.
     */
    public void removeVulnerability(Vulnerability vulnerability) {

        vulnerabilities.remove(vulnerability);
    }

    /**
     * Generates one new {@link Vulnerability} from the given {@link VulnSource} object.
     * The source is used as a general description of the new vulnerability.
     * See the javadoc of the {@link VulnSource} class for more information on the generation process.
     *
     * @param source The vulnerability source that generally describes the new vulnerability.
     */
    public void generateVulnerability(VulnSource source) {

        Random random = getNonNullRandom();

        List<VulnerabilityAction> vulnActions = new ArrayList<>();

        boolean selectedOneAction = false;
        while (!selectedOneAction) {
            for (Action action : source.getActions()) {
                if (ProbabilityUtils.gen(action.getVulnProbability(), random)) {
                    vulnActions.add(new VulnerabilityAction(action.getName(), action.getAttackWeight()));
                    selectedOneAction = true;
                }
            }
        }

        vulnerabilities.add(new Vulnerability(vulnActions));
    }

    /**
     * Generates multiple new {@link Vulnerability vulnerabilities} from the given {@link VulnSource} objects.
     * The sources are used as general descriptions of the new vulnerabilities.
     * The algorithm selects sources for each new vulnerability using the source weights.
     * See the javadoc of the {@link VulnSource} class for more information on the generation process.<br>
     * <br>
     * Note that an amount of {@code 1} can be used to generate one vulnerability using a randomly selected source.
     *
     * @param sources The vulnerability sources that generally describe the new vulnerability.
     *        The ones which are actually used will be randomly selected.
     * @param amount The amount of vulnerabilities that should be generated.
     */
    public void generateVulnerabilities(Collection<VulnSource> sources, int amount) {

        for (int counter = 0; counter < amount; counter++) {
            generateVulnerability(selectVulnSource(sources));
        }
    }

    private VulnSource selectVulnSource(Collection<VulnSource> sources) {

        int totalWeights = 0;
        for (VulnSource vulnSource : sources) {
            totalWeights += vulnSource.getWeight();
        }

        Random random = getNonNullRandom();
        int randomPosition = random.nextInt(totalWeights);

        int currentPosition = 0;
        for (VulnSource vulnSource : sources) {
            int weight = vulnSource.getWeight();

            if (randomPosition >= currentPosition && randomPosition < currentPosition + weight) {
                return vulnSource;
            } else {
                currentPosition += weight;
            }
        }

        // Should never happen
        throw new RuntimeException("Cannot select vulnerability source because generated position '" + randomPosition + "' cannot be found in '" + totalWeights + "'");
    }

    private Random getNonNullRandom() {

        Random random = getRandom();

        if (random == null) {
            return new Random();
        } else {
            return random;
        }
    }

    /**
     * Returns the action (string) that should be executed because the given {@link Attack} arrived at the container user.
     * Note that {@code "null"} (yes, a string whose content is {@code "null"}) is also possible if the used {@link Vulnerability} does not exist.
     *
     * @param attack The attack whose resulting action should be returned.
     * @return The action that should be executed.
     */
    public String processAttack(Attack attack) {

        Vulnerability vulnerability = attack.getVulnerability();

        String action;
        if (vulnerabilities.contains(vulnerability)) {
            action = attack.getPreferredAction();
        } else {
            action = "null";
        }

        return action;
    }

}
